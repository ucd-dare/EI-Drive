"""
This module contains a local planner to provide low-level waypoint for controllers.
"""

import statistics
import math
import carla
import numpy as np

from collections import deque
from enum import Enum
from EIdrive.core.basic.auxiliary import distance_to_vehicle, visualize_trajectory, \
    distance_angle_to_target, calculate_distance
from EIdrive.core.plan.cubic_spline import Spline2D


class RoadOption(Enum):
    """
    RoadOption show the topological configurations when shifting from one part of road to another.
    """
    VOID = -1
    LEFT = 1
    RIGHT = 2
    STRAIGHT = 3
    LANEFOLLOW = 4
    CHANGELANELEFT = 5
    CHANGELANERIGHT = 6


class LocalPlanner(object):
    """
    LocalPlanner implements the basic behavior of following a trajectory of
    waypoints that is generated on-the-fly.The low-level motion of the vehicle
    is computed by using lateral and longitudinal PID controllers. When
    multiple paths are available (intersections) this local planner makes
    a random choice.

    Parameters
    ----------
    agent : carla.agent
        The carla agent in charge of vehicle control.

    world_map : carla.map
        The map of the current world.

    config : dict
        Configuration settings for the trajectory planning.

    Attributes
    ----------
    vehicle : carla.vehicle
        The carla vehicle.

    vehicle_pos : carla.position
        The current position of the ego vehicle.

    vehicle_speed : float
        The current speed of the ego vehicle.

    cur_global_route : deque
        The waypoint deque of the current global route.

    global_route_buffer : deque
        A buffer deque to store the current global route.

    path_debug : list
        A list that stores a part of global plan for debug.

    trajectory_buffer : deque
        A deque buffer that stores the current trajectory.

    history_buffer : deque
        A deque buffer that stores the trajectory history.

    potential_curved_road : boolean
        Indicates if the road is likely curved based on lane's ID and its lateral changes.

    lane_id_change : boolean Tracks corner cases where lane ID remains unchanged despite notable lateral differences,
    thus being seen as a lane change.
    """

    def __init__(self, agent, world_map, config):
        self.vehicle = agent.vehicle
        self.map = world_map

        self.vehicle_pos = None
        self.vehicle_speed = None
        self.min_distance = config['min_dist']
        self.buffer_size = config['buffer_size']

        # Global route
        self.cur_global_route = deque(maxlen=20000)
        # Global route buffer restores the global route
        self.global_route_buffer = deque(maxlen=self.buffer_size)
        # Trajectory buffer
        self.path_debug = []
        self.trajectory_buffer = deque(maxlen=30)
        self.history_buffer = deque(maxlen=3)
        self.trajectory_update_freq = config['trajectory_update_freq']
        self.global_route_update_freq = config['global_route_update_freq']
        self.trajectory_sample_horizon = config['trajectory_sample_horizon']

        # Trajectory update frequency
        self.dt = config['trajectory_dt']

        # Checks related to road curvature and lane changes
        self.potential_curved_road = False
        self.lane_id_change = False
        self.lane_lateral_change = False

        # Debug settings
        self.debug = config['debug']
        self.debug_trajectory = config['debug_trajectory']

    def update_global_route(self, current_route, reset=False):
        """
            Updates the global plan with the provided waypoints.

            Parameters
            ----------
            current_route : list
                Current global route generated by global planner.

            reset : boolean
                If set to True, the global plan buffer is cleared.

            """
        for waypoint in current_route:
            self.cur_global_route.append(waypoint)

        if reset:
            self.global_route_buffer.clear()
            for _ in range(self.buffer_size):
                if self.cur_global_route:
                    self.global_route_buffer.append(self.cur_global_route.popleft())
                else:
                    break

    def update_vehicle_info(self, vehicle_pos, vehicle_speed):
        """
        Update the ego position and speed for trajectory planner.

        Parameters
        ----------
        vehicle_pos : carla.Transform
            Vehicle position.

        vehicle_speed : float
            Vehicle speed.

        """
        self.vehicle_pos = vehicle_pos
        self.vehicle_speed = vehicle_speed

    def get_trajectory(self):
        """
        Get the trajectory buffer.

        Returns :
        ----------
        self.trajectory_buffer : deque
            Trajectory buffer.

        """
        return self.trajectory_buffer

    def get_global_route(self):
        """
        Get the global_route_buffer.

        Returns
        -------
        self.global_route_buffer : deque
            A buffer deque stores global route.

        """
        return self.global_route_buffer

    def get_waypoints_queue(self):
        """
        Get the cur_global_route.
        Returns
        -------
        self.cur_global_route : deque
            The waypoint deque of the current plan.

        """
        return self.cur_global_route

    def get_history_buffer(self):
        """
        Get the history buffer

        Returns
        -------
        self.history_buffer : deque
            A deque buffer that stores the trajectory history.

        """
        return self.history_buffer

    def generate_local_path(self):
        """
        Compute a smooth local path using cubic spline interpolation.

        Returns
        -------
        path_x : list
            x coordinates of the interpolated path.

        path_y : list
            y coordinates of the interpolated path.

        path_yaw : list
            Yaw angles of the interpolated path.

        path_curvature : list
            Curvature values of the interpolated path.
        """

        # Gather key spline nodes.
        spline_x, spline_y = [], []

        # Filter out waypoints that may affect driving.
        self.filter_global_route()

        # Distance between interpolated points.
        interpolation_distance = 0.1

        # Fetch current position and orientation of the vehicle.
        current_loc = self.vehicle_pos.location
        current_yaw = self.vehicle_pos.rotation.yaw

        # Get the waypoint corresponding to the current location.
        current_wpt = self.map.get_waypoint(current_loc).next(1)[0]
        current_wpt_loc = current_wpt.transform.location

        # Determine if a lane change is upcoming.
        future_wpt = self.global_route_buffer[-1][0] if self.global_route_buffer else current_wpt
        past_wpt = self.history_buffer[0][0] if self.history_buffer else current_wpt

        # Evaluate lateral offset between past and future waypoints.
        distance, offset_angle = distance_angle_to_target(past_wpt.transform.location, future_wpt.transform.location, future_wpt.transform.rotation.yaw)
        lateral_offset = abs(distance * math.sin(math.radians(offset_angle - 1 if offset_angle > 90 else offset_angle + 1)))

        veh_dims = self.vehicle.bounding_box
        veh_half_width = abs(veh_dims.location.y - veh_dims.extent.y)
        road_width = current_wpt.lane_width

        self.lane_lateral_change = veh_half_width < lateral_offset
        self.lane_id_change = future_wpt.lane_id != current_wpt.lane_id or past_wpt.lane_id != future_wpt.lane_id
        self.potential_curved_road = self.lane_id_change or self.lane_lateral_change

        # Incorporate historical waypoints into trajectory.
        waypoint_idx = 0
        for i, (wpt, _) in enumerate(self.history_buffer):
            loc = wpt.transform.location
            _, yaw_angle = distance_angle_to_target(loc, current_loc, current_yaw)

            if yaw_angle > 90 and not self.potential_curved_road:
                spline_x.append(loc.x)
                spline_y.append(loc.y)
                waypoint_idx += 1
            if self.potential_curved_road:
                spline_x.append(loc.x)
                spline_y.append(loc.y)
                waypoint_idx += 1

        # Determine current position for the trajectory.
        if self.potential_curved_road:
            spline_x.append(current_loc.x)
            spline_y.append(current_loc.y)
        else:
            _, yaw_angle = distance_angle_to_target(current_wpt_loc, current_loc, current_yaw)
            if yaw_angle < 90:
                spline_x.append(current_wpt_loc.x)
                spline_y.append(current_wpt_loc.y)
            else:
                spline_x.append(current_loc.x)
                spline_y.append(current_loc.y)

        # Filter closely located waypoints.
        waypoint_idx = max(0, waypoint_idx - 1) if self.potential_curved_road else waypoint_idx
        last_x, last_y = spline_x[waypoint_idx], spline_y[waypoint_idx]
        for wpt, _ in self.global_route_buffer:
            loc = wpt.transform.location
            if abs(last_x - loc.x) < 0.5 and abs(last_y - loc.y) < 0.5:
                continue
            last_x, last_y = loc.x, loc.y
            spline_x.append(last_x)
            spline_y.append(last_y)

        # Execute cubic spline interpolation.
        path_x, path_y, path_yaw, path_curvature = [], [], [], []

        if len(spline_x) < 2 or len(spline_y) < 2:
            return path_x, path_y, path_curvature, path_yaw

        spline_path = Spline2D(spline_x, spline_y)
        diff_s = np.hypot(current_loc.x - spline_path.x_spline.y[0], current_loc.y - spline_path.y_spline.y[0])

        s_values = np.arange(diff_s, spline_path.arc_lengths[-1], interpolation_distance)
        self.path_debug = []
        for i, s in enumerate(s_values):
            interpolated_x, interpolated_y = spline_path.get_position(s)
            if abs(interpolated_x - spline_x[waypoint_idx]) <= interpolation_distance and abs(interpolated_y - spline_y[waypoint_idx]) <= interpolation_distance:
                continue
            if i <= len(s_values) // 2:
                self.path_debug.append(carla.Transform(carla.Location(interpolated_x, interpolated_y, 0)))
            path_x.append(interpolated_x)
            path_y.append(interpolated_y)
            path_curvature.append(max(min(spline_path.get_curvature(s), 0.2), -0.2))
            path_yaw.append(spline_path.get_yaw(s))

        return path_x, path_y, path_curvature, path_yaw

    def generate_trajectory(self, path_x, path_y, path_curvature):
        """
        Sample the given local path and assign speed for each waypoint to generate trajectory.

        Parameters
        ----------
        path_x : list
            List of x coordinates of the trajectory provided by generate_local_path.

        path_y : list
            List of y coordinates of the trajectory.

        path_curvature : list
            List of curvature values of the trajectory.

        """
        # Define the distance increment between interpolation points
        ds = 0.1
        # Define the time increment for sampling
        dt = self.dt

        desired_speed = self.desired_speed
        present_speed = self.vehicle_speed

        # Set a future horizon for sampling
        future_horizon = self.trajectory_sample_horizon // dt

        reached_end = False
        present_speed /= 3.6  # Convert km/h to m/s
        sampling_dist = 0

        # Calculate speed constraint based on average curvature
        avg_curvature = 0.0001 if len(path_curvature) < 2 else abs(statistics.mean(path_curvature))
        speed_constraint = min(desired_speed, np.sqrt(5.0 / (avg_curvature + 10e-6)) * 3.6)

        max_acceleration = 3.5  # Maximum possible acceleration
        # Compute acceleration ensuring it lies within the constraints
        acc = max(min(max_acceleration, (speed_constraint / 3.6 - present_speed) / dt), -6.5)

        for step in range(1, int(future_horizon) + 1):
            sampling_dist += present_speed * dt + 0.5 * acc * dt ** 2
            present_speed += acc * dt

            # Check if we've reached the end of the path
            if int(sampling_dist // ds - 1) >= len(path_x):
                final_x = path_x[-1]
                final_y = path_y[-1]
                reached_end = True
            else:
                final_x = path_x[max(0, int(sampling_dist // ds - 1))]
                final_y = path_y[max(0, int(sampling_dist // ds - 1))]

            # Append the sampled point and speed to the trajectory buffer
            self.trajectory_buffer.append(
                (carla.Transform(
                    carla.Location(
                        final_x,
                        final_y,
                        self.global_route_buffer[0][0].transform.location.z + 0.5)),
                 desired_speed))
            if reached_end:
                break

    def filter_global_route(self):
        """
        Refines the global route by removing waypoints that could result in sudden yaw angle changes.
        """
        last_waypoint = None

        temp_buffer = self.global_route_buffer.copy()

        for idx, (current_waypoint, _) in enumerate(temp_buffer):

            # Limit the examination to nearby waypoints
            if idx >= 3:
                break

            # Adjust the index to align with the original buffer after potential deletions
            adjusted_idx = idx - (len(temp_buffer) - len(self.global_route_buffer))

            # Determine if the waypoint is behind the vehicle. If so, remove it.
            _, yaw_angle = distance_angle_to_target(
                current_waypoint.transform.location,
                self.vehicle_pos.location, self.vehicle_pos.rotation.yaw)

            if yaw_angle > 90:
                # print('Removing waypoint behind the vehicle!')
                del self.global_route_buffer[adjusted_idx]
                continue

            if last_waypoint is None:
                last_waypoint = current_waypoint
                continue

            # Remove those next waypoint on the other lane and is too close, which leads to abrupt steering actions.
            if last_waypoint.lane_id != current_waypoint.lane_id and len(self.global_route_buffer) >= 2:
                distance_between = calculate_distance(current_waypoint.transform.location,
                                                      last_waypoint.transform.location)

                if distance_between <= 4.5:
                    del self.global_route_buffer[adjusted_idx]

            last_waypoint = current_waypoint

    def remove_visited_waypoints(self, vehicle_transform):
        """
        Remove those trajectory waypoints that the ego vehicle has visited.
        
        Parameters
        ----------
        vehicle_transform : carla.transform
            The transform of vehicle.
        """
        last_visited_idx = -1

        # Identify last visited waypoint in global route buffer
        for idx, (waypoint, _) in enumerate(self.global_route_buffer):
            if distance_to_vehicle(waypoint, vehicle_transform) < self.min_distance:
                last_visited_idx = idx

        # Remove the identified waypoints and append them to history buffer
        if last_visited_idx >= 0:
            for _ in range(last_visited_idx + 1):
                if self.history_buffer:
                    last_history = self.history_buffer[-1]
                    next_waypoint = self.global_route_buffer.popleft()

                    if abs(
                            last_history[0].transform.location.x -
                            next_waypoint[0].transform.location.x) > 4.5 or abs(
                        last_history[0].transform.location.y -
                        next_waypoint[0].transform.location.y) > 4.5:
                        self.history_buffer.append(next_waypoint)
                    else:
                        self.history_buffer.append(
                            self.global_route_buffer.popleft())

        # Identify and remove visited waypoints in trajectory buffer
        if self.trajectory_buffer:
            last_visited_trajectory_idx = -1
            for idx, (waypoint, _) in enumerate(self.trajectory_buffer):
                if distance_to_vehicle(waypoint, vehicle_transform) < \
                        max(self.min_distance - 1, 1):
                    last_visited_trajectory_idx = idx

            if last_visited_trajectory_idx >= 0:
                for _ in range(last_visited_trajectory_idx + 1):
                    self.trajectory_buffer.popleft()

    def run_trajectory_planning(
            self,
            path_x,
            path_y,
            curvatures,
            desired_speed=None):
        """
        Conducts one iteration of trajectory planning.

        Parameters
        ----------
        path_x : list
            X coordinates of the planned path points.

        path_y : list
            Y coordinates of the planned path points.

        curvatures : list
            Curvatures of the planned path points.

        desired_speed : float, optional
            The preferred speed for the ego vehicle.

        Returns
        -------
        trajectory_speed : float
            Speed for the upcoming trajectory point.

        next_point_location : carla.location
            Location for the upcoming trajectory point.

        """
        self.desired_speed = desired_speed

        # Keep the waypoint buffer populated
        if len(self.global_route_buffer) < self.global_route_update_freq:
            for _ in range(self.buffer_size - len(self.global_route_buffer)):
                if self.cur_global_route:
                    self.global_route_buffer.append(self.cur_global_route.popleft())
                else:
                    break

        # Generate trajectory if required
        if len(self.trajectory_buffer) < self.trajectory_update_freq:
            self.trajectory_buffer.clear()
            if len(path_x) == 0:  # return if no spline points available
                return 0, None
            self.generate_trajectory(path_x, path_y, curvatures)

        # get waypoint and speed
        self.target_waypoint, self.desired_speed = self.trajectory_buffer[min(1, len(self.trajectory_buffer) - 1)]

        # Remove visited waypoints
        vehicle_position = self.vehicle_pos
        self.remove_visited_waypoints(vehicle_position)

        # Debug visualization
        if self.debug_trajectory:
            visualize_trajectory(self.vehicle.get_world(), self.path_debug, color=carla.Color(0, 255, 0), size=0.05, life_time=0.1)
        if self.debug:
            visualize_trajectory(self.vehicle.get_world(), self.global_route_buffer, size=0.1, color=carla.Color(0, 0, 255), life_time=0.2)
            visualize_trajectory(self.vehicle.get_world(), self.history_buffer, size=0.1, color=carla.Color(255, 0, 255), life_time=0.2)

        trajectory_speed = self.desired_speed
        next_point_location = self.target_waypoint.transform.location if hasattr(self.target_waypoint, 'is_junction') else self.target_waypoint.location

        return trajectory_speed, next_point_location
